<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mengrr&#39;s Blog</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-26T07:27:44.273Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>孟瑞瑞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS远程推送原理及实现过程</title>
    <link href="http://yoursite.com/2018/02/28/iOS%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/02/28/iOS远程推送原理及实现过程/</id>
    <published>2018-02-28T09:01:00.000Z</published>
    <updated>2018-03-26T07:27:44.273Z</updated>
    
    <content type="html"><![CDATA[<p><code>该文章是我16年在公司博客上写的，除了证书注册的过程大致没有改变，像接收通知的方法都有所改变，所以将iOS 10 之后的接收通知及注册通知的方法在文章中补全，希望对正在处理远程推送的伙伴们有所帮助</code></p><h1 id="一-、推送原理"><a href="#一-、推送原理" class="headerlink" title="一 、推送原理"></a>一 、推送原理</h1><p>推送通知，是现在的应用必不可少的功能。那么在 iOS 中，我们是如何实现远程推送的呢？iOS 的远程推送原理又是什么呢？在做 iOS 远程推送时，我们会遇到各种各样的问题。<a id="more"></a>那么首先让我们准备一些做推送需要的东西。我们需要一个付费的苹果开发者账号（免费的不可以做远程推送），有了开发者账号，我们可以去苹果开发者网站，配置自己所需要的推送的相关证书。然后下载证书，供我们后面使用，详细的证书配置过程，我们下面再说。<br>首先我们要说说iOS推送通知的基本原理：<br>苹果的推送服务通知是由自己专门的推送服务器APNs （Apple Push Notification service）来完成的，其过程是 APNs 接收到我们自己的应用服务器发出的被推送的消息，将这条消息推送到指定的 iOS 的设备上，然后再由 iOS设备通知到我们的应用程序，我们将会以通知或者声音的形式收到推送回来的消息。 iOS 远程推送的前提是，装有我们应用程序的 iOS 设备，需要向 APNs 服务器注册，注册成功后，APNs 服务器将会给我们返回一个 devicetoken，我们获取到这个 token 后会将这个 token 发送给我们自己的应用服务器。当我们需要推送消息时，我们的应用服务器将消息按照指定的格式进行打包，然后结合 iOS 设备的 devicetoken 一起发给 APNs 服务器。我们的应用会和 APNs 服务器维持一个基于 TCP 的长连接，APNs 服务器将新消息推送到iOS 设备上，然后在设备屏幕上显示出推送的消息。</p><p>设备注册APNs的流程图：<br><img src="http://upload-images.jianshu.io/upload_images/1463570-ca0caf2de6cf472d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注册APNs的流程图.png"></p><p>上图完成了如下步骤：</p><ol><li><p>Device（设备）连接APNs服务器并携带设备序列号（UUID）</p></li><li><p>连接成功，APNs经过打包和处理产生devicetoken并返回给注册的Device（设备）</p></li><li><p>Device（设备）携带获取的devicetoken发送到我们自己的应用服务器</p></li><li><p>完成需要被推送的Device（设备）在APNs服务器和我们自己的应用服务器的注册</p></li></ol><p>推送过程图:</p><p><img src="http://upload-images.jianshu.io/upload_images/1463570-656099c1661467a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="推送过程图.png"></p><p>推送的过程经过如下步骤：</p><ol><li><p>首先，我们的设备安装了具有推送功能的应用（应用程序要用代码注册消息推动），我们的 iOS设备在有网络的情况下会连接APNs推送服务器，连接过程中，APNS 服务器会验证devicetoken，连接成功后维持一个基于TCP 的长连接；</p></li><li><p>Provider(我们自己的应用服务器)收到需要被推送的消息并结合被推送的 iOS设备的devicetoken一起打包发送给APNS服务器；</p></li><li><p>APNS服务器将推送信息推送给指定devicetoken的iOS设备；</p></li><li><p>iOS设备收到推送消息后通知我们的应用程序并显示和提示用户（声音、弹出框）</p></li></ol><p>比较直观的流程图:</p><p><img src="http://upload-images.jianshu.io/upload_images/1463570-a938d50322912f3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="直观的流程图.png"></p><p>信息包结构图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1463570-ebed9d244f9e22c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="信息包结构图.png"></p><p>上图显示的这个消息体就是我们的应用服务器（Provider）发送给APNs服务器的消息结构，APNs验证这个结构正确并提取其中的信息后，再将消息推送到指定的iOS设备。这个结构体包括五个部分，第一个部分是命令标示符，第二个部分是我们的devicetoken的长度，第三部分是我们的devicetoken字符串，第四部分是推送消 息体（Payload）的长度，最后一部分也就是真正的消息内容了，里面包含了推送消息的基本信息，比如消息内容，应用Icon右上角显示多少数字以及推送消息到达时所播放的声音等</p><p>Payload（消息体）的结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">“aps”:&#123;</span><br><span class="line">“alert”:“听云给您发送了新消息”,</span><br><span class="line">“badge”:1,</span><br><span class="line">“sound”:“default”</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是个JSON结构体，alert标签的内容就是会显示在用户手机上的推送信息，badge显示的数量（注意是整型）是会在应用Icon右上角显示的数量，提示有多少条未读消息等，sound就是当推送信息送达是手机播放的声音，传defalut就标明使用系统默认声音。</p><h1 id="二、证书及推送实现过程"><a href="#二、证书及推送实现过程" class="headerlink" title="二、证书及推送实现过程"></a>二、证书及推送实现过程</h1><ol><li>首先我们要新建一个Certificate Signing Request(也就是CSR)的请求文件</li></ol><ul><li><p>在应用程序里的使用工具中找到钥匙串访问，选择从证书颁发机构请求证书<br><img src="http://upload-images.jianshu.io/upload_images/1463570-94ccf8e9d04c613f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/1463570-a5e3cd2634b1c92f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/1463570-003c14a8cfca1848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>保存位置在 tingyun（指定自己的文件夹，这里我选择的是我的文件夹）,点击存储。</p></li><li><p>然后点击完成后我们会在 tingyun 里看到一个CertificateSigningRequest.certSigningRequest的请求文件，也就是我们说的CSR文件。在我们生成CSR文件的同时，会在钥匙串访问中生成一对秘钥，名称为刚才我们填写的常用名。</p></li></ul><ol><li>配置AppID</li></ol><ul><li>到苹果开发者网站<a href="https://developer.apple.com" target="_blank" rel="noopener">https://developer.apple.com</a></li><li>点击Account<br><img src="http://upload-images.jianshu.io/upload_images/1463570-fbdff9ce53344011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>选择 Certificates,identifiers&amp;Profiles<br><img src="http://upload-images.jianshu.io/upload_images/1463570-a5b98c5aebbf492f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>选择 Identifiers -&gt;App IDs 点击上方的+号创建一个 App ID.<br><img src="http://upload-images.jianshu.io/upload_images/1463570-a89d4b5078e62c88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>Name: 填写 App 的名字就行</li><li>App ID Suffix 选择不用通配符的及 Explicit App ID</li><li><p>Bundle ID:填写自己应用的 Bundle ID 一定要和自己应用的一致.<br><img src="http://upload-images.jianshu.io/upload_images/1463570-8d11e70397ee8a7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>在下面的 App Services 中选择自己需要的服务，我们需要推送服务,所以在Push Notifications上打勾，然后点击continue。<br><img src="http://upload-images.jianshu.io/upload_images/1463570-cbbf1deb6f9892fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><ol><li>创建证书</li></ol><ul><li>证书需要创建两种，一种是开发的、一种是发布的，开发的是做测试用的。</li><li><p>选择Development 点击右上角的+号,创建证书,我们首先创建开发证书<br><img src="http://upload-images.jianshu.io/upload_images/1463570-e0048885dd74a878.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>选择Apple Push Notification service SSL (Sandbox),创建推送服务证书点击下一步<br><img src="http://upload-images.jianshu.io/upload_images/1463570-83a9be82600fccf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>这儿的 App ID 选择我们刚才创建的 App ID，然后点击下一步,下一步</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1463570-5f4147b1e72cbf30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>这儿点击 Choose File,选择我们刚才创建的 CSR 文件，然后点击生成(Generate)。最后点击下载,下载证书。将下载的证书，放到指定位置。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1463570-bb3e7e5ba3c6e791.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>发布证书的创建和开发证书一样,选择Production-&gt;Apple Push Notification service SSL (Production)，后面和开发证书一样。<br><img src="http://upload-images.jianshu.io/upload_images/1463570-81bca2c63a7792db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><ol><li>添加 Devices （一个公司账号、企业账号或者个人账号，可添加100个设备）：</li></ol><ul><li><p>首先选中你要添加哪种设备，然后在左上角点击“+”号。<br><img src="http://upload-images.jianshu.io/upload_images/1463570-761d2174711b3fa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>Name 填写一个设备名字，UDID 填写自己需要加入测试的设备的 UDID，然后点击下一步。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1463570-5a9f3983a12151fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>然后点击 Register 即可</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1463570-597b505945f0eada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>点击Done。<br><img src="http://upload-images.jianshu.io/upload_images/1463570-0c6050068aa15d31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><ol><li>查找设备的 UDID：</li></ol><ul><li>用自己的 iOS 设备连接到电脑上，打开 iTunes。在设备摘要处可以看见一个序列号，点击序列号就会变成 UDID。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1463570-fd56a5fbab06f8d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol><li>生成配置文件</li></ol><ul><li><p>配置文件也有两种，一种是开发的，一种是发布的，开发的使我们做测试需要的，发布的是我们在 Appstore 上发布时需要的，我们都需要生成。</p></li><li><p>我们先生成开发配置文件,选择Provisioning Profiles-&gt;Development点击右上角的+号。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1463570-172b92cb73f8b206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>选择iOS App Development 点击下一步<br><img src="http://upload-images.jianshu.io/upload_images/1463570-0eacc4340347abe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>这儿的 App ID 仍然选择我们刚才创建的 App ID<br><img src="http://upload-images.jianshu.io/upload_images/1463570-be0f8c6b987d1430.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><img src="http://upload-images.jianshu.io/upload_images/1463570-be1706b74b5eff12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>这儿选择我们开发者的证书,如果不知道是哪个选择全部即可<br><img src="http://upload-images.jianshu.io/upload_images/1463570-29a6efa9e84d6136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>这儿选择我们的测试设备,如果没有则在前面的Devices里面添加即可<br><img src="http://upload-images.jianshu.io/upload_images/1463570-fd8e4d28630ce49c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/1463570-5af3e1301eace84f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>随便取个名字即可,然后下载下来<br><img src="http://upload-images.jianshu.io/upload_images/1463570-35f940ec4a62fd2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>发布配置文件和开发配置文件一样创建,选择Distribution-&gt;Ad Hoc即可，后面与发布配置文件一样。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1463570-50209b08f857f777.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/1463570-ccd7a7da105fc5a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="三、证书配置完成-打开我们创建的应用项目"><a href="#三、证书配置完成-打开我们创建的应用项目" class="headerlink" title="三、证书配置完成,打开我们创建的应用项目"></a>三、证书配置完成,打开我们创建的应用项目</h1><p>打开AppDelegate.m 文件,在- (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions 方法中添加下面代码,注册消息推送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">// Override point for customization after application launch.</span><br><span class="line">/*</span><br><span class="line">注册通知(推送)</span><br><span class="line">申请App需要接受来自服务商提供推送消息</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 10.0) &#123;</span><br><span class="line">//iOS10特有</span><br><span class="line">UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">// 必须写代理，不然无法监听通知的接收与点击</span><br><span class="line">center.delegate = self;</span><br><span class="line">[center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert | UNAuthorizationOptionBadge | UNAuthorizationOptionSound) completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</span><br><span class="line">if (granted) &#123;</span><br><span class="line">// 点击允许</span><br><span class="line">//NSLog(@&quot;注册成功&quot;);</span><br><span class="line">[center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123;</span><br><span class="line">//NSLog(@&quot;%@&quot;, settings);</span><br><span class="line">&#125;];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 点击不允许</span><br><span class="line">// NSLog(@&quot;注册失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">else if ([[UIDevice currentDevice].systemVersion floatValue] &gt;8.0)&#123;</span><br><span class="line">//iOS8 - iOS10</span><br><span class="line">[[UIApplication sharedApplication] registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeSound | UIUserNotificationTypeBadge categories:nil]];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">UIRemoteNotificationType apn_type = (UIRemoteNotificationType)(UIRemoteNotificationTypeAlert |UIRemoteNotificationTypeSound |</span><br><span class="line">UIRemoteNotificationTypeBadge);</span><br><span class="line">[[UIApplication sharedApplication] registerForRemoteNotificationTypes:apn_type];</span><br><span class="line">&#125;</span><br><span class="line">// 注册获得device Token</span><br><span class="line">[[UIApplication sharedApplication] registerForRemoteNotifications];</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面方法是返回 ANPs 苹果推送服务器生成的唯一标识</span><br><span class="line">/** 接收服务器传回的设备唯一标识 token */</span><br><span class="line">-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123;</span><br><span class="line"></span><br><span class="line">// 第一次运行获取到DeviceToken时间会比较长！</span><br><span class="line">// 将deviceToken转换成字符串，以便后续使用</span><br><span class="line">NSString *token = [deviceToken description];</span><br><span class="line">NSLog(@&quot;description %@&quot;, token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面方法是当注册推送服务失败时,接收错误信息</span><br><span class="line">/** 注册推送服务失败 */</span><br><span class="line">-(void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error&#123;</span><br><span class="line">NSLog(@&quot;注册失败 %@&quot;,error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面方法是当有消息推送回来时,接收推送消息</span><br><span class="line">/** 设备接收到来自苹果推送服务器的消息时触发的,用来显示推送消息 */</span><br><span class="line"></span><br><span class="line">// iOS 10收到通知（前台）</span><br><span class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler&#123;</span><br><span class="line">NSDictionary * userInfo = notification.request.content.userInfo;</span><br><span class="line">UNNotificationRequest *request = notification.request; // 收到推送的请求</span><br><span class="line">UNNotificationContent *content = request.content; // 收到推送的消息内容</span><br><span class="line">NSNumber *badge = content.badge;  // 推送消息的角标</span><br><span class="line">NSString *body = content.body;    // 推送消息体</span><br><span class="line">UNNotificationSound *sound = content.sound;  // 推送消息的声音</span><br><span class="line">NSString *subtitle = content.subtitle;  // 推送消息的副标题</span><br><span class="line">NSString *title = content.title;  // 推送消息的标题</span><br><span class="line"></span><br><span class="line">if([notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) &#123;</span><br><span class="line">NSLog(@&quot;iOS10 前台收到远程通知:%@&quot;, [self logDic:userInfo]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// 判断为本地通知</span><br><span class="line">NSLog(@&quot;iOS10 前台收到本地通知:&#123;\\\\nbody:%@，\\\\ntitle:%@,\\\\nsubtitle:%@,\\\\nbadge：%@，\\\\nsound：%@，\\\\nuserInfo：%@\\\\n&#125;&quot;,body,title,subtitle,badge,sound,userInfo);</span><br><span class="line">&#125;</span><br><span class="line">completionHandler(UNNotificationPresentationOptionBadge|UNNotificationPresentationOptionSound|UNNotificationPresentationOptionAlert); // 需要执行这个方法，选择是否提醒用户，有Badge、Sound、Alert三种类型可以设置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//iOS 10  通知的点击事件（点击通知）</span><br><span class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler&#123;</span><br><span class="line"></span><br><span class="line">NSDictionary * userInfo = response.notification.request.content.userInfo;</span><br><span class="line">UNNotificationRequest *request = response.notification.request; // 收到推送的请求</span><br><span class="line">UNNotificationContent *content = request.content; // 收到推送的消息内容</span><br><span class="line">NSNumber *badge = content.badge;  // 推送消息的角标</span><br><span class="line">NSString *body = content.body;    // 推送消息体</span><br><span class="line">UNNotificationSound *sound = content.sound;  // 推送消息的声音</span><br><span class="line">NSString *subtitle = content.subtitle;  // 推送消息的副标题</span><br><span class="line">NSString *title = content.title;  // 推送消息的标题</span><br><span class="line">if([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) &#123;</span><br><span class="line">NSLog(@&quot;iOS10 收到远程通知:%@&quot;, [self logDic:userInfo]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// 判断为本地通知</span><br><span class="line">NSLog(@&quot;iOS10 收到本地通知:&#123;\\\\nbody:%@，\\\\ntitle:%@,\\\\nsubtitle:%@,\\\\nbadge：%@，\\\\nsound：%@，\\\\nuserInfo：%@\\\\n&#125;&quot;,body,title,subtitle,badge,sound,userInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Warning: UNUserNotificationCenter delegate received call to -userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler: but the completion handler was never called.</span><br><span class="line">completionHandler();  // 系统要求执行这个方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//iOS 6 及以下系统通知</span><br><span class="line">- (void)application:(UIApplication *)application</span><br><span class="line">didReceiveRemoteNotification:(NSDictionary *)userInfo &#123;</span><br><span class="line">NSLog(@&quot;iOS6及以下系统，收到通知:%@&quot;,userInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//iOS 7 及以上系统通知（前台/后台）</span><br><span class="line">- (void)application:(UIApplication *)application</span><br><span class="line">didReceiveRemoteNotification:(NSDictionary *)userInfo</span><br><span class="line">fetchCompletionHandler:</span><br><span class="line">(void (^)(UIBackgroundFetchResult))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;iOS7及以上系统，收到通知:%@&quot;,userInfo);</span><br><span class="line">completionHandler(UIBackgroundFetchResultNewData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、服务器端-Java服务器"><a href="#四、服务器端-Java服务器" class="headerlink" title="四、服务器端(Java服务器)"></a>四、服务器端(Java服务器)</h1><p> 服务器端我们需要,一个后缀为. p12的证书,以及需要的 jar 包</p><p> 服务器端的证书生成方式:</p><p>1、打开我们前面下载的证书,在钥匙串中找到它<br><img src="http://upload-images.jianshu.io/upload_images/1463570-79adf30b20f2bfc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>2、点击鼠标右键选择导出<br><img src="http://upload-images.jianshu.io/upload_images/1463570-f7ce3a5618612a70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>3、导出后缀为.p12的文件保存到自己的电脑上,需要输入一个密码,在 Java 服务器端要用到<br><img src="http://upload-images.jianshu.io/upload_images/1463570-7a28e8f97d7f6d18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>4、Java服务器端需要的 Jar 包</p><p><img src="http://upload-images.jianshu.io/upload_images/1463570-79393eb3db814f4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>5、Java 服务器端代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import javapns.back.PushNotificationManager;</span><br><span class="line">import javapns.back.SSLConnectionHelper;</span><br><span class="line">import javapns.data.Device;</span><br><span class="line">import javapns.data.PayLoad;</span><br><span class="line">public class pushService &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">//这个token  就是客户端从APNs服务器获取到的devicetoken</span><br><span class="line">String deviceToken = &quot;eab6df47eb4f81e0aaa93bb208cffd7dc3884fd346ea0743fcf93288018cfcb6&quot;;</span><br><span class="line">//被推送的iphone应用程序标示符</span><br><span class="line">PayLoad payLoad = new PayLoad();</span><br><span class="line">payLoad.addAlert(&quot;测试我的push消息&quot;);</span><br><span class="line">payLoad.addBadge(1);</span><br><span class="line">payLoad.addSound(&quot;default&quot;);</span><br><span class="line"></span><br><span class="line">PushNotificationManager pushManager = PushNotificationManager.getInstance();</span><br><span class="line">pushManager.addDevice(&quot;iphone&quot;, deviceToken);</span><br><span class="line"></span><br><span class="line">//测试推送服务器地址：gateway.sandbox.push.apple.com /2195</span><br><span class="line">//产品推送服务器地址：gateway.push.apple.com / 2195</span><br><span class="line">String host=&quot;gateway.sandbox.push.apple.com&quot;;  //测试用的苹果推送服务器</span><br><span class="line">int port = 2195;</span><br><span class="line">String certificatePath = &quot;/Users/hsw/Desktop/PushTest/PushTest.p12&quot;; //刚才在mac系统下导出的证书</span><br><span class="line"></span><br><span class="line">String certificatePassword= &quot;123456&quot;;</span><br><span class="line"></span><br><span class="line">pushManager.initializeConnection(host, port, certificatePath,certificatePassword, SSLConnectionHelper.KEYSTORE_TYPE_PKCS12);</span><br><span class="line"></span><br><span class="line">//Send Push</span><br><span class="line">Device client = pushManager.getDevice(&quot;iphone&quot;);</span><br><span class="line">pushManager.sendNotification(client, payLoad); //推送消息</span><br><span class="line">pushManager.stopConnection();</span><br><span class="line">pushManager.removeDevice(&quot;iphone&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">System.out.println(&quot;push faild!&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;push succeed!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意，我有看到转载的提问，服务端是否需要deviceToken，这个肯定是需要的，在上面Java的代码中也有写到。deviceToken是设备唯一的推送标识，服务端只有知道这个标识，才能够将通知推送到你的设备上。</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;该文章是我16年在公司博客上写的，除了证书注册的过程大致没有改变，像接收通知的方法都有所改变，所以将iOS 10 之后的接收通知及注册通知的方法在文章中补全，希望对正在处理远程推送的伙伴们有所帮助&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-、推送原理&quot;&gt;&lt;a href=&quot;#一-、推送原理&quot; class=&quot;headerlink&quot; title=&quot;一 、推送原理&quot;&gt;&lt;/a&gt;一 、推送原理&lt;/h1&gt;&lt;p&gt;推送通知，是现在的应用必不可少的功能。那么在 iOS 中，我们是如何实现远程推送的呢？iOS 的远程推送原理又是什么呢？在做 iOS 远程推送时，我们会遇到各种各样的问题。
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/iOS/"/>
    
      <category term="Objective - c" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/iOS/Objective-c/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Objective - c" scheme="http://yoursite.com/tags/Objective-c/"/>
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>iOS判断对象相等 重写isEqual、isEqualToClass、hash</title>
    <link href="http://yoursite.com/2017/11/16/iOS%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%20%E9%87%8D%E5%86%99isEqual%E3%80%81isEqualToClass%E3%80%81hash/"/>
    <id>http://yoursite.com/2017/11/16/iOS判断对象相等 重写isEqual、isEqualToClass、hash/</id>
    <published>2017-11-16T06:14:00.000Z</published>
    <updated>2018-03-25T01:53:49.000Z</updated>
    
    <content type="html"><![CDATA[<p> 相等的概念是探究哲学和数学的核心，并且对道德、公正和公共政策的问题有着深远的影响。</p><p>从一个经验主义者的角度来看，两个物体不能依据一些观测标准中分辨出来，它们就是相等的。在人文方面，平等主义者认为相等意味着要保持每个人的社会、经济、政治和他们住地的司法系统都一致。</p><a id="more"></a><p>对程序员来说，协调好逻辑和感官能力来理解我们塑造的’相同’的语义是一项任务。’相同的问题’(的探讨)太微妙，同时有太容易被忽视。对语义没有充分的理解就直接去实现它，可能会导致没必要的工作和不正确的结果。因此对数学和逻辑系统的深刻理解与按既定计划实现同样必要。</p><p>虽然所有的技术博文都是有诱惑你来读它的标题和代码，但请花几分钟时间来阅读和理解这些文字。逐字地复制看似有用的代码而不知道为什么这样写很有可能导致一些错误。相等性是个重要话题之一，但它仍包含了许多混乱的概念，尤其是在Objective-C中。</p><h2 id="Equality-amp-Identity"><a href="#Equality-amp-Identity" class="headerlink" title="Equality &amp; Identity"></a>Equality &amp; Identity</h2><p> 首先，弄清楚equality和identity的区别很重要。</p><p>如果两个物体具有相同的观测属性，它们是可以相互等同的。但是，这两个对象仍然可以分辨出差异，它们各自的identity。在程序中，一个对象的identity是和它的内存地址关联的。</p><p>NSObject对象测试和另一个对象是否相同使用isEqual:方法，在它的基本实现里性等性检查本质上是对identity的检查，如果两个对象指向了相同的内存地址，它们被认为是相等的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@implementation NSObject(Approximate)</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line"></span><br><span class="line">return self== object;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>对于内置的类，像NSArray, NSDictionary, 和 NSString，进行了一个深层的相等性比较，来测试在集合中的每个元素是否相等，这是一个应该也确实非常有用的做法。</p><p>NSObject 的子类要实现它们各自的isEqual:方法时，应该做到以下几点：</p><ul><li><p>1.实现一个isEqualTo__ClassName__:方法来执行有意义的值比较.</p></li><li><p>2.重写isEqual:方法 来作类型和对象identity检查, 回调上述的值比较方法.</p></li><li><p>3.重写 hash, 这个会在下一部分解释.</p></li><li><p>这里有一个NSArray实现这个的大概的思路(这个例子忽略了类簇, 实际实现会更具体复杂):</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@implementation NSArray(Approximate)</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqualToArray:(NSArray*)array &#123;</span><br><span class="line"></span><br><span class="line">if(!array || [selfcount] != [array count]) &#123;</span><br><span class="line"></span><br><span class="line">return NO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(NSUIntegeridx =0; idx &lt; [array count]; idx++) &#123;</span><br><span class="line"></span><br><span class="line">if(![self[idx] isEqual:array[idx]]) &#123;</span><br><span class="line"></span><br><span class="line">return NO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return YES;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line"></span><br><span class="line">if(self== object) &#123;</span><br><span class="line"></span><br><span class="line">return YES;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(![object isKindOfClass:[NSArrayclass]]) &#123;</span><br><span class="line"></span><br><span class="line">return NO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return [selfisEqualToArray:(NSArray*)object];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>下面的在Foudation中NSObject的子类已经自定义了判等实现，用了相关的方法：</p><p><code>NSAttributedString-isEqualToAttributedString:</code><br><code>NSData-isEqualToData:NSDate-isEqualToDate:</code><br><code>NSDictionary-isEqualToDictionary:</code><br><code>NSHashTable-isEqualToHashTable:</code><br><code>NSIndexSet-isEqualToIndexSet:</code><br><code>NSNumber-isEqualToNumber:</code><br><code>NSOrderedSet-isEqualToOrderedSet:</code><br><code>NSSet-isEqualToSet:</code><br><code>NSString-isEqualToString:</code><br><code>NSTimeZone-isEqualToTimeZone:</code><br><code>NSValue-isEqualToValue:</code></p><p>当比较任何这些类的两个实例时，推荐使用它们各自的高级别的<code>method</code>而不是<code>isEqual:</code></p><p>然而，我们的理论实现还没有完成，现在，让我们把注意力转向<code>hash</code>（一段插曲：先清理一下<code>NSString</code>的问题）。</p><p><code>NSString</code>判等的奇怪案例</p><p>一个有趣的插曲，看一下这个代码：</p><p><code>NSString *a = @&quot;Hello&quot;;</code><br><code>NSString *b =@&quot;Hello&quot;;</code><br><code>BOOL wtf = (a == b);</code><br><code>// YES</code></p><p>郑重地声明一下正确的比较两个<code>NSString</code>对象相等的方法是使用<code>-isEqualToString:</code>方法，无论如何也不能通过<code>==</code>操作符来比较两个<code>NSString</code>。</p><p>那么这里是怎么回事呢？为什么 <code>NSArray</code>或者<code>NSDictionary</code>字面量相同不会这样，而它<code>(NSString)</code>会这样呢。</p><p>这都是一种被称为字符串驻留的优化技术做的，因为这种优化不同的值可以对一份不可变的字符串值的备份进行拷贝。<code>NSString</code> 类型的a指针和b指针对驻留字符串 <code>@&quot;Hello&quot;</code>进行了相同的拷贝。注意这个优化仅仅对静态声明的不可变字符串有效。</p><p>更有趣的是，<code>OC</code>的<code>selector</code>的名字也会被当做驻留字符串存储在一个共用的字符串<code>pool</code>中。</p><h2 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h2><p>最日常的面向对象编程来说，对象判等最主要的用法在于决定集合成员。为了让这一步更快一些，自定义判等实现的类应该也实现hash:</p><ul><li><p>1.对象相等是相互的([a isEqual:b] ⇒ [b isEqual:a])</p></li><li><p>2.如果对象相等，它们的hash值必须相等([a isEqual:b] ⇒ [a hash] == [b hash])</p><p>但是，反过来不一定成立：如果它们的hash值相等，两个对象不一定相等。([a hash] == [b hash] ¬⇒ [a isEqual:b])</p></li></ul><p>现在快速翻看一下《计算机科学》101:</p><p><code>hash</code>表式编程中的基本的数据结构，它可以使 <code>NSSet &amp; NSDictionary</code> 快速地(O(1))查找它的元素。</p><p>我们也可以通过对比着数组很好地理解hash表：</p><p><code>Arrays</code>按照有序的索引存储元素，因此一个大小为n的数组会把元素放在索引1，2直到n-1.为了确定数组中的一个元素存在了哪里，不得不一个个检查每个位置(除非数组碰巧已经排序好，但这是另一回事)。</p><p>Hash表使用了略微不同的方法。而不是按顺序存储元素，<code>hash</code>表在内存中分配了n个位置，同时用一个函数来计算在这个范围内计算一个位置。一个<code>hash</code>函数是确定性的，同时一个好的<code>hash</code>函数使用一个相对均匀的散列来生成值，而且不会有太多的计算过程。当两个不同的对象计算出相同的hash值时，会产生<code>hash</code>冲突。当冲突发生时，<code>hash</code>表会寻找冲突点同时把新加的对象放到第一个可用的位置。当<code>hash</code>表变得越来越拥挤，冲突的可能性会增加，这会导致花费更多的时间来寻找空间(这就是为什么均匀散列的<code>hash</code>函数不菲的原因。)</p><p>一个关于实现<code>hash</code>函数的错误共识来自于随之发生的断言，这个错误的共识认为<code>hash</code>值必须是不同的。这个错误共识会导致不必要地复杂实现，包括从<code>Java textbooks</code>复制过来的质数的神奇咒语。实际上，一个简单的对关键属性<code>hash</code>值的<code>XOR</code>(异或运算)对于99%的情况来说已经够用了。</p><p>技巧就是思考对象中的哪个值是关键的。</p><p>对 <code>NSDate</code> 来说，对参照日期的时间间隔已经够用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@implementation NSDate(Approximate)</span><br><span class="line"></span><br><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line"></span><br><span class="line">return (NSUInteger) abs ( [self timeIntervalSinceReferenceDate] ) ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 对UIColor来说，移位之后的RGB值是非常方便计算的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@implementation UIColor(Approximate)</span><br><span class="line"></span><br><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line"></span><br><span class="line">CGFloatred, green, blue;</span><br><span class="line"></span><br><span class="line">[selfgetRed:&amp;red green:&amp;green blue:&amp;blue alpha:nil];</span><br><span class="line"></span><br><span class="line">return ((NSUInteger)(red *255) &lt;&lt;16) + ((NSUInteger)(green *255) &lt;&lt;8) + (NSUInteger)(blue *255);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="在子类中实现-isEqual-和-hash"><a href="#在子类中实现-isEqual-和-hash" class="headerlink" title="在子类中实现 -isEqual: 和 hash"></a>在子类中实现 -isEqual: 和 hash</h2><p>综合在一起，这里有一个如何在子类重写默认的判等实现的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interfacePerson</span><br><span class="line"></span><br><span class="line">@property NSString*name;</span><br><span class="line"></span><br><span class="line">@property NSDate*birthday;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqualToPerson:(Person *)person;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementationPerson</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqualToPerson:(Person *)person &#123;</span><br><span class="line"></span><br><span class="line">if(!person) &#123;</span><br><span class="line"></span><br><span class="line">return NO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL haveEqualNames = (!self.name &amp;&amp; !person.name) || [self.name  isEqualToString:person.name];</span><br><span class="line"></span><br><span class="line">BOOL haveEqualBirthdays = (!self.birthday &amp;&amp; !person.birthday) || [self.birthday isEqualToDate:person.birthday];</span><br><span class="line"></span><br><span class="line">return haveEqualNames &amp;&amp; haveEqualBirthdays;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - NSObject</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line"></span><br><span class="line">if(self== object) &#123;</span><br><span class="line"></span><br><span class="line">return YES;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(![object isKindOfClass:[Person class]]) &#123;</span><br><span class="line"></span><br><span class="line">return NO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return [self isEqualToPerson:(Person *)object];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSUInteger)hash &#123;</span><br><span class="line"></span><br><span class="line">return [self.name hash] ^ [self.birthday hash];</span><br><span class="line"></span><br><span class="line">&#125;@end</span><br></pre></td></tr></table></figure><p> 如果想满足好奇心或者出于学究式的研究，看一下这个 <a href="https://mikeash.com/pyblog/friday-qa-2010-06-18-implementing-equality-and-hashing.html" target="_blank" rel="noopener">Mike Ash的文章</a>，解释了通过移位和翻转组合值如何改善了可能产生重叠(冲突)的hash.</p><p>本文完全翻译自：<a href="http://nshipster.com/equality/" target="_blank" rel="noopener">http://nshipster.com/equality/</a></p><p>本文转自 <a href="https://www.cnblogs.com/Mike-zh/p/5147041.html" target="_blank" rel="noopener">https://www.cnblogs.com/Mike-zh/p/5147041.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 相等的概念是探究哲学和数学的核心，并且对道德、公正和公共政策的问题有着深远的影响。&lt;/p&gt;
&lt;p&gt;从一个经验主义者的角度来看，两个物体不能依据一些观测标准中分辨出来，它们就是相等的。在人文方面，平等主义者认为相等意味着要保持每个人的社会、经济、政治和他们住地的司法系统都一致。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/iOS/"/>
    
      <category term="Objective - c" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/iOS/Objective-c/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Objective - c" scheme="http://yoursite.com/tags/Objective-c/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>iPhone X 屏幕适配，没有铺满屏幕的情况</title>
    <link href="http://yoursite.com/2017/09/20/iPhone%20X%20%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%EF%BC%8C%E6%B2%A1%E6%9C%89%E9%93%BA%E6%BB%A1%E5%B1%8F%E5%B9%95%E7%9A%84%E6%83%85%E5%86%B5/"/>
    <id>http://yoursite.com/2017/09/20/iPhone X 屏幕适配，没有铺满屏幕的情况/</id>
    <published>2017-09-20T06:00:14.000Z</published>
    <updated>2018-03-25T01:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在适配iPhone X的时候，发现iPhone X的屏幕上下没有铺满。新建的项目，以及写的Demo都是铺满屏幕的。</p><p><img src="/images/1463570-f79d80f2215fd3df.png.jpeg" alt=""></p><a id="more"></a><p>经过反复查看项目后，发现原来是很久以前，项目因为启动页用的是Launch Image Source,而用不到Launch Screen File 所以把LaunchScreen.storyboard 给删除了，Info.plist 里面也就没有了 Launch screen interface file base name 。</p><p>解决方法是，在Info.plist 里面增加  Launch screen interface file base name 就可以了。</p><p>注意：只是增加一个 key。Launch screen interface file base name</p><p>如果增加了key，还是不行的话，添加一张iPhone X屏幕分辨率的启动图也能达到一样的效果。</p><p><img src="/images/1463570-444c8cb57e883c57.png.jpeg" alt=""></p><p>增加完的效果是，我们要注意的是，在iPhone X 里面，状态栏是不能隐藏的。如果隐藏了，会挡住界面，需要自己再去做适配。</p><p><img src="/images/1463570-daeae66fb1f438aa.png.jpeg" alt=""></p><p>付一张启动页的图，需要的可以先试试。</p><p><img src="/images/1463570-a30a07c2a45b888f.jpg.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在适配iPhone X的时候，发现iPhone X的屏幕上下没有铺满。新建的项目，以及写的Demo都是铺满屏幕的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/1463570-f79d80f2215fd3df.png.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/iOS/"/>
    
      <category term="Objective - c" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/iOS/Objective-c/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Objective - c" scheme="http://yoursite.com/tags/Objective-c/"/>
    
      <category term="原创" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
</feed>
